#nombre d'individus
n <- nrow(Th)
#nombre de modalite
K <- nlevels(y)
#nombre de variables desc
p <- ncol(Th)
#proportion par classe
pi_k <- n_k / n
#calcul des moyennes conditionelles - lignes = classes
mb_k <- as.matrix(aggregate(Th,list(y),mean)[,2:(p+1)])
#calcul des matrices de covariances conditionnelles
V_k <- by(as.matrix(Th),list(y),cov)
#matrice de covariance intra-classe W
#calculée à partir des matrices conditionnelles V_k
W <- 1/(n-K) * Reduce("+",lapply(levels(y),function(k){(n_k[k]-1)*V_k[[k]]}))
#inverse de la matrice W
invW <- solve(W)
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
#revenir a toutes les var originelles
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_ <- diag(1/apply(X.init, 2, sd)) %*% coef_
intercept_ <- as.vector(apply(nipals.res$Y.iter,2,sd) - apply(X.init, 2, mean) %*% coef_)
intercept_
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
intercept_
intercept <- as.vector(1/apply(X.init,2,sd) %*% intercept_)
#intercept_ <- as.vector(apply(ydum,2,sd) - apply(X.init, 2, mean) %*% coef_)
intercept_
1/apply(X.init,2,sd)
intercept <- as.vector(1/apply(ydum,2,sd) %*% intercept_)
intercept
intercept <- diag(1/apply(X.init, 2, sd)) %*% intercept_
intercept <- diag(1/apply(ydum, 2, sd)) %*% intercept_
intercept
1/apply(ydum, 2, sd)
diag(1/apply(ydum, 2, sd))
intercept <- diag(apply(ydum, 2, sd)) %*% intercept_
intercept
intercept <- diag(apply(mean)) %*% intercept_
intercept
intercept <- diag(apply(ydum, 1, mean)) %*% intercept_
intercept
intercept <- diag(apply(ydum, 2, mean)) %*% intercept_
intercept
intercept <- diag(1/apply(ydum, 2, mean)) %*% intercept_
intercept
diag(1/apply(X.init, 2, mean))
intercept <- diag(1/apply(ydum, 2, mean)) %*% intercept_
intercept
intercept <- diag(1/apply(ydum, 2, sd)) %*% intercept_
intercept
#intercept_ <- as.vector(apply(ydum,2,sd) - apply(X.init, 2, mean) %*% coef_)
intercept_
intercept_dampeel <- as.vector(apply(ydum,2,sd) - apply(X.init, 2, mean) %*% coef_)
intercept_dampeel
apply(X.init, 2, sd)
sd(X.init)
intercept_
intercept <- diag(apply(coef_, 2, sd)) %*% intercept_
intercept
diag(apply(coef_, 2, sd))
intercept_
intercept <- diag(coef_) %*% intercept_
intercept
intercept <- coef_ %*% intercept_
intercept
coef_
intercept_
intercept <- diag(1/apply(coef_, 2, sd)) %*% intercept_
intercept
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
#revenir a toutes les var originelles
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
coef=coef_
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
#revenir a toutes les var originelles
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_ <- diag(1/apply(X.init, 2, sd)) %*% coef_
intercept_dampeel <- as.vector(apply(ydum,2,sd) - apply(X.init, 2, mean) %*% coef_)
intercept_dampeel
intercept_
intercept <- diag(1/apply(coef, 2, sd)) %*% intercept_
intercept
intercept <- diag(apply(coef, 2, sd)) %*% intercept_
intercept
intercept <- diag(apply(mean)) %*% intercept_
intercept
intercept <- diag(apply(coef, 2, mean)) %*% intercept_
intercept
intercept <- diag(1/apply(coef, 2, mean)) %*% intercept_
intercept
intercept <- diag(apply(coef, 2, mean)) %*% intercept_
intercept <- diag(apply(coef, 2, sd)) %*% intercept_
intercept
intercept_
coef_
intercept_
nipals.res
as.matrix(nipals.res$poid_Y)%*%intercept_
as.matrix(nipals.res$poid_Y)
t(as.matrix(nipals.res$poid_Y))%*%intercept_
intercept <- t(as.matrix(nipals.res$poid_Y))%*%intercept_
intercept <- diag(1/apply(X.init, 2, sd)) %*% intercept
intercept <- diag(1/apply(ydum, 2, sd)) %*% intercept
intercept_dampeel <- as.vector(apply(ydum,2,sd) - apply(X.init, 2, mean) %*% coef_)
intercept_dampeel <- as.vector(apply(X.init, 2, mean) %*% coef_)
intercept_dampeel
intercept_dampeel <- as.vector(1/apply(X.init, 2, mean) %*% coef_)
intercept_dampeel
intercept_dampeel <- as.vector(apply(ydum,2,sd) - apply(X.init, 2, mean) %*% coef_)
intercept_dampeel
intercept_
intercept <- diag(1/apply(ydum, 2, sd)) %*% intercept
intercept <- diag(1/apply(ydum, 2, sd)) %*% intercept_
intercept <- diag(apply(coef, 2, sd)) %*% intercept_
intercept <- diag(1/apply(ydum, 2, sd)) %*% intercept_
intercept
intercept <- diag(1/apply(ydum, 2, sd)) %*% intercept_dampeel
intercept
intercept <- diag(apply(ydum, 2, sd)) %*% intercept_dampeel
intercept
intercept <- diag(apply(coef, 2, sd)) %*% intercept_
intercept
intercept <- diag(1/apply(coef, 2, sd)) %*% intercept_
intercept
mb_k
invW
mb_k
pi_k
intercept <- diag(apply(ydum, 2, sd)) %*% intercept_
intercept
intercept <- diag(1/apply(ydum, 2, sd)) %*% intercept_
intercept
nipals.res$poid_X
intercept_
coef_
as.matrix(nipals.res$poid_X)
coef_
as.matrix(nipals.res$poid_X)
t(coef_) %*% as.matrix(nipals.res$poid_X)
coef_
coef
as.matrix(nipals.res$poid_X) %*% coef
nipals.res$comp_X
nipals.res$poid_X
X
nipals.res$poid_X[,1]
nipals.res$comp_X[,1]
nipals.res$poid_X
nipals.res$poid_X[,1]
X
nipals.res$comp_X[,1]
nipals.res$poid_X[,1]
nipals.res$comp_X[,1]%*%nipals.res$poid_X[,1]
as.matrix(nipals.res$comp_X[,1])%*%as.matrix(nipals.res$poid_X[,1])
as.matrix(nipals.res$comp_X[,1])
as.matrix(nipals.res$poid_X[,1])%*%as.matrix(nipals.res$comp_X[,1])
as.matrix(nipals.res$comp_X)
as.matrix(nipals.res$poid_X)%*%as.matrix(nipals.res$comp_X[,1])
as.matrix(nipals.res$comp_X[,1])
X%*%as.matrix(nipals.res$comp_X[,1])
X
as.matrix(nipals.res$comp_X[,1])
X%*%as.matrix(nipals.res$comp_X[,1])
t(X)%*%as.matrix(nipals.res$comp_X[,1])
as.matrix(nipals.res$comp_X[,1])
as.matrix(nipals.res$poid_X[,1])
X%*%as.matrix(nipals.res$poid_X[,1])
X
as.matrix(nipals.res$poid_X[,1])
as.matrix(X)%*%as.matrix(nipals.res$poid_X[,1])
nipals.res$comp_X[,1]
nipals.res$comp_X[,1]-as.matrix(X)%*%as.matrix(nipals.res$poid_X[,1])
nipals.res$comp_X[,2]-as.matrix(X)%*%as.matrix(nipals.res$poid_X[,2])
nipals.res$comp_X[,4]-as.matrix(X)%*%as.matrix(nipals.res$poid_X[,4])
nipals.res$poid_X
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
coef=coef_
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
#revenir a toutes les var originelles
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_
coef_
coef_ <- diag(1/apply(X.init, 2, sd)) %*% coef_
coef_
intercept_dampeel <- as.vector(apply(ydum,2,sd) - apply(X.init, 2, mean) %*% intercept_)
intercept_dampeel <-diag(1/apply(ydym, 2, sd))  %*% intercept_
intercept_dampeel <-diag(1/apply(ydum, 2, sd))  %*% intercept_
intercept_dampeel
intercept_dampeel <- as.vector(apply(ydum,2,sd) - apply(X.init, 2, mean) %*% coef_)
intercept_dampeel
intercept_ <- diag(1/apply(X.init, 2, sd)) %*% intercept_
as.matrix(nipals.res$poid_X)
intercept_
as.matrix(nipals.res$poid_Y)
intercept_ <- intercept_ %*% as.matrix(nipals.res$poid_Y)
intercept_
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
coef=coef_
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
#revenir a toutes les var originelles
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_
coef_ <- diag(1/apply(X.init, 2, sd)) %*% coef_
coef_
X%*%coef_
X
coef_
as.matrix(X)%*%as.matrix(coef_)
intercept_ <- intercept_ %*% as.matrix(nipals.res$poid_Y)
intercept_ <- diag(1/apply(X.init, 2, sd)) %*% intercept_
intercept_
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
intercept_
intercept_ <- intercept_ %*% as.matrix(nipals.res$poid_Y)
intercept_
diag(1/apply(X.init, 2, sd)) %*% intercept_
diag(1/apply(X.init, 2, sd))
diag(apply(X.init, 2, mean))
intercept_
apply(X.init, 2, mean)
coef_
Th=X.init
Th
#effectif par classe
n_k <- table(y) #train
#nombre d'individus
n <- nrow(Th)
#nombre de modalite
K <- nlevels(y)
#nombre de variables desc
p <- ncol(Th)
#proportion par classe
pi_k <- n_k / n
#calcul des moyennes conditionelles - lignes = classes
mb_k <- as.matrix(aggregate(Th,list(y),mean)[,2:(p+1)])
#calcul des matrices de covariances conditionnelles
V_k <- by(as.matrix(Th),list(y),cov)
#matrice de covariance intra-classe W
#calculée à partir des matrices conditionnelles V_k
W <- 1/(n-K) * Reduce("+",lapply(levels(y),function(k){(n_k[k]-1)*V_k[[k]]}))
#inverse de la matrice W
invW <- solve(W)
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
intercept_
Th=X
X
#effectif par classe
n_k <- table(y) #train
#nombre d'individus
n <- nrow(Th)
#nombre de modalite
K <- nlevels(y)
#nombre de variables desc
p <- ncol(Th)
#proportion par classe
pi_k <- n_k / n
#calcul des moyennes conditionelles - lignes = classes
mb_k <- as.matrix(aggregate(Th,list(y),mean)[,2:(p+1)])
#calcul des matrices de covariances conditionnelles
V_k <- by(as.matrix(Th),list(y),cov)
#matrice de covariance intra-classe W
#calculée à partir des matrices conditionnelles V_k
W <- 1/(n-K) * Reduce("+",lapply(levels(y),function(k){(n_k[k]-1)*V_k[[k]]}))
#inverse de la matrice W
invW <- solve(W)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
intercept_
as.matrix(nipals.res$poid_X)
coef_
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
coef=coef_
colnames(coef_) <- levels(y)
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
coef_
as.matrix(nipals.res$poid_X)
#Récupération des X et Y
X <- as.matrix(model.matrix(formula, data = data)[,-1])
X.init <- X
y <- as.factor(model.response(model.frame(formula, data = data)))
#si data est a standardiser
if ((mean(apply(X,2,mean))>abs(1)) || (sum(sqrt(apply(X,2,var))) != ncol(X))){
X <- plsda.scale(X)
}
#codage disjonctif de la variable cible
ydum <- plsda.dummies(y)
nipals.res <- plsda.nipals(X=X, y=ydum, ncomp=ncomp , max.iter=max.iter, tol=tol)
#ici on effectue la LDA pour la classification
#on l'a fait sur nos compossntes principales Th, obtenues en sorties de la PLS
Th <- nipals.res$comp_X
Th=X
#effectif par classe
n_k <- table(y) #train
#ici on effectue la LDA pour la classification
#on l'a fait sur nos compossntes principales Th, obtenues en sorties de la PLS
Th <- nipals.res$comp_X
#effectif par classe
n_k <- table(y) #train
#nombre d'individus
n <- nrow(Th)
#nombre de modalite
K <- nlevels(y)
#nombre de variables desc
p <- ncol(Th)
#proportion par classe
pi_k <- n_k / n
#calcul des moyennes conditionelles - lignes = classes
mb_k <- as.matrix(aggregate(Th,list(y),mean)[,2:(p+1)])
#calcul des matrices de covariances conditionnelles
V_k <- by(as.matrix(Th),list(y),cov)
#matrice de covariance intra-classe W
#calculée à partir des matrices conditionnelles V_k
W <- 1/(n-K) * Reduce("+",lapply(levels(y),function(k){(n_k[k]-1)*V_k[[k]]}))
#inverse de la matrice W
invW <- solve(W)
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
coef_
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
as.matrix(nipals.res$poid_X)
intercept_ - log(pi_k) + log(1/K)
intercept_
log(pi_k)
log(1/K)
intercept_
intercept_
inter_corr = intercept_ - log(pi_k) + log(1/K)
print(round(inter_corr,6))
intercept<- intercept_ %*% as.matrix(nipals.res$poid_Y)
intercept <- diag(apply(X.init, 2, mean)) %*% intercept
intercept
as.matrix(nipals.res$poid_Y)
intercept_
intercept<- ydum %*% as.matrix(nipals.res$poid_Y)
intercept
ydum
as.matrix(nipals.res$poid_Y)
intercept<- as.matrix(ydum) %*% as.matrix(nipals.res$poid_Y)
intercept
intercept <- diag(apply(X.init, 2, mean)) %*% intercept
diag(apply(X.init, 2, mean))
intercept <- diag(apply(ydum, 2, mean)) %*% intercept
diag(apply(ydum, 2, mean))
intercept
intercept <- diag(apply(ydum, 2, mean)) %*% t(intercept)
t(intercept)
diag(apply(ydum, 2, mean))
intercept<- as.matrix(ydum) %*% as.matrix(nipals.res$poid_Y)
intercept
as.matrix(ydum)
as.matrix(nipals.res$poid_Y)
intercept_
intercept <- intercept_ %*% as.matrix(nipals.res$poid_Y)
intercept
as.matrix(nipals.res$poid_X)
t(as.matrix(nipals.res$poid_Y))
intercept <-  as.matrix(nipals.res$poid_X) %*% t(as.matrix(nipals.res$poid_Y))
intercept
intercept_
intercept %*% t(intercept_)
intercept
t(intercept_)
as.matrix(intercept_)
intercept %*% as.matrix(intercept_)
as.matrix(nipals.res$poid_X)
t(as.matrix(nipals.res$poid_Y))
test <- as.matrix(nipals.res$poid_X) %*% coef
X
y
y<-ydum
X.init <- as.matrix(X)
Y.init <- as.matrix(y)
#initialisation
comp_names <- paste0('PC', seq_len(ncomp))
#matrice des coordonnées des composantes de X
#/ coefficients de projection de des composantes X
#/ poids de X
W <- data.frame(matrix(rep(NA), nrow = ncol(X.init), ncol=ncomp))
rownames(W) <- colnames(X.init)
#matrice des variables latentes de X
#/ composantes principales
Tx <- data.frame(matrix(rep(0), nrow = nrow(X.init), ncol=ncomp))
names(Tx) <- comp_names
#matrice des variables latentes de Y
U <- data.frame(matrix(rep(0), nrow = nrow(Y.init), ncol=ncomp))
names(U) <-comp_names
#matrice des coefficients des composantes de Y
#/ coefficients de projection de des composantes Y
#/ poids de Y
Q <- data.frame(matrix(rep(NA), nrow = ncol(Y.init), ncol = ncomp))
rownames(Q) <- colnames(Y.init)
nc.ones <- rep(1, ncol(X))
nr.ones <- rep(1, nrow(X))
is.na.X <- is.na(X)
na.X <- any(is.na.X)
X.iter = X.init #X0
Y.iter = Y.init #Y0
#on déroule l'algorithme NIPALS pour calculer les composantes de X et Y
for(k in 1:ncomp){
#u = premiere colonne de Yk-1
u <- as.matrix(Y.iter[,1])
u[is.na(u)] <- 0
#initialisations
w.old <- 1/rep(sqrt(ncol(X)), ncol(X))
w <- vector("numeric", length = ncol(X))
iter <- 1
diff <- 1
if (na.X)
{
X.aux <- X.iter
X.aux[is.na.X] <- 0
}
#on boucle jusqu'à ce que wk converge
while (diff > tol & iter <= max.iter){
if (na.X)
{
#calcul des poids w de X
w <- crossprod(X.aux, u)
Th <- drop(u) %o% nc.ones
Th[is.na.X] <- 0
u.cross <- crossprod(Th)
w <- w / diag(u.cross)
w <- w / drop(sqrt(crossprod(w)))
#calcul de la composante u de Xk-1
u <- X.aux %*% w
M <- drop(w) %o% nr.ones
M[t(is.na.X)] <- 0
ph.cross <- crossprod(M)
u <- u / diag(ph.cross)
} else {
#wk
w <- crossprod(X.iter, u) / drop(crossprod(u))
#normer a 1
w <- w / drop(sqrt(crossprod(w)))
#calcul de la composante u de Xk-1
#pk ca fait 1 le drop(crossprod(w)) ???
t <- X.iter %*% w / drop(crossprod(w)) #tk
}
#calcul des poids de Yk-1
q <- crossprod(Y.iter,t)/drop(crossprod(t)) #qk
#prochiane colonne de Yk-1
u<-Y.iter  %*% q / drop(crossprod(q)) #x valeurs pour les x modalités
diff <- drop(sum((w - w.old)^2, na.rm = TRUE))
w.old <- w
iter = iter + 1
}
if (iter > max.iter){
message(paste("Maximum number of iterations reached for comp: ", k))
}
#SVD de X
#eigTx[k] <- sum(t * t, na.rm = TRUE)
#P
P=crossprod(X.iter,t)/drop(crossprod(t))
#mise à jour des X
X.iter <- X.iter - t %*% t(P)
#mise à jour des Y
Y.iter <- Y.iter - t%*%t(q)
#stocker les resultats pour la sortie
#matrice des composantes de X
Tx[,k] <- t
#matrice des composantes de Y
U[,k] <- u
#matrice des poids des composante X
W[,k] <- w
#matrice des poids des composante Y
Q[,k] <- q
}
Rx <- cor(X.init,Tx)^2
colnames(Rx) <- paste(rep("Comp",ncomp), 1:ncomp, sep=" ")
if (ncomp == 1) {
Var.Explained.X <- rbind(Rx,Redundancy=mean(Rx))
Rx.cum <- as.matrix(apply(Rx,1,cumsum))
Var.Explained.X.Cum <- rbind(Rx.cum,Redundancy=mean(Rx.cum))
} else {
Var.Explained.X <- rbind(Rx,Redundancy=colMeans(Rx))
Rx.cum <- t(apply(Rx,1,cumsum))
Var.Explained.X.Cum <- rbind(Rx.cum,Redundancy=colMeans(Rx.cum))
}
Var.Explained.X
Rx.cum
Var.Explained.X.Cum
Tx
Var.Explained.X.Cum
sample(nrow(X))
